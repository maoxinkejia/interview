# 面试-高级

## JUC多线程及高并发
#### volatile的理解
* volatile是java虚拟机提供的轻量级的同步机制
	* 保证可见性
	* 不保证原子性
	* 禁止指令重排

* JMM内存模型
	* JMM（java内存模型Java Memory Model）本身是一种抽象的概念，并不真实存在，他描述的是一组规则或规范，
	通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。
	* JMM关于同步的规定
		```
		1.线程解锁前，必须把共享变量的值刷新回主内存
		2.线程加锁前，必须读取主内存的最新值到自己的工作内存
		3.加锁解锁是同一把锁
		```
	* 由于JVM运行程序的实际是线程，而每个线程创建时JVM都会为其创建一个工作内存，工作内存是每个线程的
	私有数据区域，而java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，
	但线程对变量的操作（读取赋值等）必须要工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，
	然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中存储主内存中的
	变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程的通信（传值）必须通过主内存来完成。

	* JMM内存模型在多线程开发中需要遵循以下特性
		* 可见性
			```
			各个线程对内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回到主内存中的。
			若线程A修改了共享变量X的值但还未写回主内存时，另外一个线程B又对主内存中的共享变量X进行操作，
			此时A线程工作内存中共享变量X对于B线程来说并不可见。这种工作内存与主内存同步延迟现象就造成了可见性问题。
			```
		* 原子性
		
		* 有序性
		    ```
		    1.计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下步骤：
		      源代码 -->> 编译器优化的重排 -->> 指令并行的重排 -->> 内存系统的重排 -->> 最终执行的指令
		    
		    2.单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。
		    3.处理器在进行重排序时必须要考虑指令之间的数据依赖性。
		    4.多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。
		    ```

* 哪里用到过volatile
    * 单例模式DCL
        ```
        DCL（Double Check Lock，双端检锁）机制并不一定线程安全，因为有指令重排序存在，加入volatile可以禁止指令重排。
        原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。
        instance = new instance();可以分为以下3步完成
        memory = allocate(); // 1.分配对象内存空间
        instance(memory); // 2.初始化对象
        instance = memory; // 3.设置instance指向刚分配的内存地址，此时instance != null
        
        因为步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重拍后的执行结果在单线程中并没有改变，因此这种重排是允许的。
        
        ```
    
#### CAS
##### CAS是什么？
* 比较并交换 (Compare And Swap)
* CAS的底层原理
    * UnSafe类
    ```
    1.Unsafe 是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，
      基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，起内部方法操作可以像C的指针一样直接操作内存，因为
      Java中CAS操作的执行依赖于Unsafe类的方法。
    ** Unsafe类中的所有方法都是native修饰的，也就是说，Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。
    2.变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。
    3.变量value用volatile修饰，保证了多线程之间的内存可见性。
    ```
    * 工作原理
    ```
    1.CAS是一条CPU并发原语。
    2.它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。
    3.CAS并发原语体现在Java语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现CAS汇编指令。
      这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，
      是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说
      CAS是一条CPU原子指令，不会造成所谓的数据不一致问题。 
    ```
    
* CAS缺点
    * 如果CAS失败，会一直进行尝试，若长时间不成功，对CPU的开销很大。
    * 只能保证一个共享变量的操作，若对多个共享变量操作时，就需要锁来保证原子性了。
    * 引发ABA问题
        * ABA问题是怎么产生的
        * 原子引用 AtomicReference
        * 时间戳原子引用 AtomicStampedReference

#### 集合类不安全问题
##### java.util.ConcurrentModificationException
* 导致原因
    * 并发争抢修改导致，一个人正在写，另外一个人过来抢夺，导致数据的不一致性
* 解决方案
    * new Vector<>();
    * Collections.synchronizedList(new ArrayList<>());
    * new CopyOnWriteArrayList<>();
* 写时复制技术思想
```
    CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器object[]进行copy，
再将原容器的引用指向新容器 setArray(newElements); 这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前
容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想。
```
* CopyOnWriteArraySet底层是CopyOnWriteArrayList, HashSet底层是HashMap

    
    
    
    
    
    
    
    
    