# 面试-高级

## JUC多线程及高并发
#### volatile的理解
* volatile是java虚拟机提供的轻量级的同步机制
	* 保证可见性
	* 不保证原子性
	* 禁止指令重排

* JMM内存模型
	* JMM（java内存模型java memory model）本身是一种抽象的概念，并不真实存在，他描述的是一组规则或规范，
	通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。
	* JMM关于同步的规定
		1.线程解锁前，必须把共享变量的值刷新回主内存
		2.线程加锁前，必须读取主内存的最新值到自己的工作内存
		3.加锁解锁是同一把锁
	* 由于JVM运行程序的实际是线程，而每个线程创建时JVM都会为其创建一个工作内存，工作内存是每个线程的
	私有数据区域，而java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，
	但线程对变量的操作（读取赋值等）必须要工作内存中进行，首先要将变量存主内存拷贝到自己的工作内存空间，
	然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中存储主内存中的
	变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程的通信（传值）必须通过主内存来完成。

	* JMM内存模型在多线程开发中需要遵循以下特性
		* 可见性
			```
			各个线程对内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回到主内存中的。
			若线程A修改了共享变量X的值但还未写回主内存时，另外一个线程B又对主内存中的共享变量X进行操作，
			此时A线程工作内存中共享变量X对于B线程来说并不可见。这种工作内存与主内存同步延迟现象就造成了可见性问题。
			```
		* 原子性
		
		* 有序性
		    ```
		    1.计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下步骤：
		      源代码 -->> 编译器优化的重排 -->> 指令并行的重排 -->> 内存系统的重派 -->> 最终执行的指令
		    
		    2.单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。
		    3.处理器在进行重排序时必须要考虑指令之间的数据依赖性。
		    4.多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。
		    ```

* 哪里用到过volatile
    * 单例模式DCL
        ```
        DCL（Double Check Lock，双端检锁）机制并不一定线程安全，因为有指令重排序存在，加入volatile可以禁止指令重排。
        原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。
        instance = new instance();可以分为以下3步完成
        memory = allocate(); // 1.分配对象内存空间
        instance(memory); // 2.初始化对象
        instance = memory; // 3.设置instance指向刚分配的内存地址，此时instance != null
        
        因为步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重拍后的执行结果在单线程中并没有改变，因此这种重排是允许的。
        
        ```
    
#### CAS
