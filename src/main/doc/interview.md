# 面试-高级

## JUC多线程及高并发
#### volatile的理解
- volatile是java虚拟机提供的轻量级的同步机制
	- 保证可见性
	- 不保证原子性
	- 禁止指令重排

- JMM内存模型
	- JMM（java内存模型Java Memory Model）本身是一种抽象的概念，并不真实存在，他描述的是一组规则或规范，
	通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。
	- JMM关于同步的规定
		```
		1.线程解锁前，必须把共享变量的值刷新回主内存
		2.线程加锁前，必须读取主内存的最新值到自己的工作内存
		3.加锁解锁是同一把锁
		```
	- 由于JVM运行程序的实际是线程，而每个线程创建时JVM都会为其创建一个工作内存，工作内存是每个线程的
	私有数据区域，而java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，
	但线程对变量的操作（读取赋值等）必须要工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，
	然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中存储主内存中的
	变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程的通信（传值）必须通过主内存来完成。

	- JMM内存模型在多线程开发中需要遵循以下特性
		- 可见性
			```
			各个线程对内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回到主内存中的。
			若线程A修改了共享变量X的值但还未写回主内存时，另外一个线程B又对主内存中的共享变量X进行操作，
			此时A线程工作内存中共享变量X对于B线程来说并不可见。这种工作内存与主内存同步延迟现象就造成了可见性问题。
			```
		- 原子性
		
		- 有序性
		    ```
		    1.计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下步骤：
		      源代码 -->> 编译器优化的重排 -->> 指令并行的重排 -->> 内存系统的重排 -->> 最终执行的指令
		    
		    2.单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。
		    3.处理器在进行重排序时必须要考虑指令之间的数据依赖性。
		    4.多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。
		    ```

- 哪里用到过volatile
    - 单例模式DCL
        ```
        DCL（Double Check Lock，双端检锁）机制并不一定线程安全，因为有指令重排序存在，加入volatile可以禁止指令重排。
        原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。
        instance = new instance();可以分为以下3步完成
        memory = allocate(); // 1.分配对象内存空间
        instance(memory); // 2.初始化对象
        instance = memory; // 3.设置instance指向刚分配的内存地址，此时instance != null
        
        因为步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重拍后的执行结果在单线程中并没有改变，因此这种重排是允许的。
        
        ```
    
#### CAS
##### CAS是什么？
- 比较并交换 (Compare And Swap)
- CAS的底层原理
    - UnSafe类
    ```
    1.Unsafe 是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，
      基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，起内部方法操作可以像C的指针一样直接操作内存，因为
      Java中CAS操作的执行依赖于Unsafe类的方法。
    *- Unsafe类中的所有方法都是native修饰的，也就是说，Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。
    2.变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。
    3.变量value用volatile修饰，保证了多线程之间的内存可见性。
    ```
    - 工作原理
    ```
    1.CAS是一条CPU并发原语。
    2.它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。
    3.CAS并发原语体现在Java语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现CAS汇编指令。
      这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，
      是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说
      CAS是一条CPU原子指令，不会造成所谓的数据不一致问题。 
    ```
    
- CAS缺点
    - 如果CAS失败，会一直进行尝试，若长时间不成功，对CPU的开销很大。
    - 只能保证一个共享变量的操作，若对多个共享变量操作时，就需要锁来保证原子性了。
    - 引发ABA问题
        - ABA问题是怎么产生的
        - 原子引用 AtomicReference
        - 时间戳原子引用 AtomicStampedReference

#### 集合类不安全问题
##### java.util.ConcurrentModificationException
- 导致原因
    - 并发争抢修改导致，一个人正在写，另外一个人过来抢夺，导致数据的不一致性
- 解决方案
    - new Vector<>();
    - Collections.synchronizedList(new ArrayList<>());
    - new CopyOnWriteArrayList<>();
- 写时复制技术思想
```
    CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器object[]进行copy，
再将原容器的引用指向新容器 setArray(newElements); 这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前
容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想。
```
- CopyOnWriteArraySet底层是CopyOnWriteArrayList, HashSet底层是HashMap


#### 公平锁/非公平锁/可重入锁/递归锁/自旋锁
##### 公平锁和非公平锁
- 是很么？
    - 公平锁：指多个县城按照申请锁的顺序来获取锁，先来后到。
    - 非公平锁：指多个线程获取锁的顺序不是按照申请锁的顺序，在高并发的情况下，有可能会造成优先级反转或者饥饿现象。
- 两者区别
    - ReentrantLock的构建函数可以指定boolean类型来得到公平锁或非公平锁，默认为非公平锁
    - 公平锁：在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，
    就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。
    - 非公平锁：比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再才用类似公平锁那种方式。
- 题外话
    - 非公平锁的优点在于吞吐量比公平锁打
    - synchronized也是一种非公平锁
    
##### 可重入锁（又名递归锁）
- 是什么
    - 指的是同一线程外层函数获得锁之后，内存递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在
    进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。
- ReentrantLock/synchronized就是一个典型的可重入锁
- 可重入锁最大的作用就是避免死锁

##### 自旋锁
- 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是
循环会消耗CPU

##### 独占锁(写锁)/共享锁(读锁)/互斥锁
- 独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和synchronized而言都是独占锁
- 共享锁：指该锁可被多个线程持有，对ReentrantReadWriteLock其读锁就是共享锁，其写锁就是独占锁。读锁的共享锁可保证
并发读是非常高效的，读写，写读，写写的过程都是互斥的。
    
    
#### CountDownLatch/CyclicBarrier/Semaphore
- CountDownLatch
    - CountDownLatch通过AQS（AbstractQueuedSynchronizer）里面的共享锁来实现的。ReentrantLock也是使用AQS
    - 使用场景： 举个例子，有三个工人在为老板干活，这个老板有一个习惯，就是当三个工人把一天的活都干完了的时候，
    他就来检查所有工人所干的活。记住这个条件：三个工人先全部干完活，老板才检查。
    
- CyclicBarrier
    - 可循环使用的屏障。集齐七颗龙珠就能召唤神龙。
    
- Semaphore
    - 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。（抢车位）
    

#### 阻塞队列
##### 概念
- 阻塞队列，顾名思义，首先它是一个队列。
    - 当阻塞队列是空时，从队列中获取元素的操作将会被阻塞
    - 当阻塞队列是满时，往队列里添加元素的操作将会被阻塞
##### 为什么用？有什么好处？
- 在多线程领域，所谓阻塞，在某些情况下会挂起线程（即阻塞），一但条件满足，被挂起的线程又会自动被环形
- 为什么需要BlockingQueue？好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都包办了
- 在JUC发布以前，在多线程环境下，每个程序员都必须自己控制这些细节，尤其还要兼顾效率和线程安全，负责度直线上升
##### 架构设计
- BlockingQueue implements Queue implements Collection
##### 实现类
- ArrayBlockingQueue：由数组结构组成的有界阻塞队列
- LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为Integer.MAX_VALUE）阻塞队列
- SynchronousQueue：不存储原色的阻塞队列，也即单个元素的队列

- PriorityBlockingQueue：支持优先级排序的无解阻塞队列
- DelayQueue：使用优先级队列实现的延迟无界阻塞队列
- LinkedTransferQueue：由链表结构组成的无界阻塞队列
- LinkedBlockingDeQue：由链表结构组成的双向阻塞队列